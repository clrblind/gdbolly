# Подробная Архитектура Web-OllyDbg (v0.1.2)

## 1. Введение и Философия
Web-OllyDbg — это амбициозный проект по переносу классического опыта реверс-инжиниринга (в духе OllyDbg 1.10) в современный веб-браузер.
В отличие от большинства веб-IDE, которые являются тонкими клиентами к терминалу, Web-OllyDbg строит полноценный графический интерфейс (GUI) поверх низкоуровневого отладчика GDB.

**Ключевые принципы:**
*   **Изоляция**: Весь процесс отладки замкнут внутри Docker-контейнера. Пользовательский браузер никогда не взаимодействует с хост-системой напрямую.
*   **Stateful Design**: Бэкенд хранит состояние процесса (запущен/остановлен, PID), а Фронтенд хранит состояние *отображения* (какую область памяти мы видим, какие регистры подсветить).
*   **Resilience (Устойчивость)**: Система спроектирована так, чтобы выживать при отладке нестабильных, "сломанных" или враждебных бинарников (stripped, malformed ELF, бесконечные циклы).

---

## 2. Компоненты Системы

Система построена на микросервисной архитектуре, где каждый компонент имеет четкую зону ответственности.

### 2.1. Высокоуровневая диаграмма
```mermaid
graph TD
    User[Browser User] -->|HTTP/REST| API[FastAPI Gateway]
    User -->|WebSocket| WS[Event Broadcaster]
    
    subgraph Frontend Logic
        Store[Redux Store]
        Hooks[Custom Hooks Logic]
        Views[React Components]
    end
    
    subgraph Backend Container
        API -->|Control| Ctrl[Extension Router]
        WS <--|Events| GDB[GDB Controller]
        
        GDB -->|MI3 Protocol| Process[GDB Subprocess]
        Process -->|Ptrace| Target[Target Binary]
        
        API -->|SQL| SQLite[(Session DB)]
    end
```

### 2.2. Frontend (The "Presentation Layer")
*   **Технологии**: React 18, Redux Toolkit, Vite.
*   **Роль**: Это не просто "отображалка". Фронтенд берет на себя всю работу по декодированию сырых байт в читаемый вид.
*   **Модули**:
    *   **Disassembler View**: Реализует сложный механизм виртуального скроллинга. Он запрашивает у бэкенда не "весь файл", а "окно в 100 инструкций" от текущего адреса. При скролле вверх вычисляются отрицательные смещения.
    *   **Address Space Normalization**: Поскольку GDB может вернуть адрес `0x400000` как строку, число или длинный hex, фронтенд приводит все к единому каноническому виду (`0x0...`), чтобы корректно работали сравнения и подсветка.

### 2.3. Backend (The "Orchestrator")
*   **Технологии**: Python 3.13, FastAPI.
*   **Почему Python?**: Необходим мощный асинхронный (asyncio) движок для одновременной обработки HTTP запросов пользователей и потока событий от GDB.
*   **GDB Controller**: Это сердце бэкенда.
    *   Он "держит" процесс GDB открытым.
    *   Он преобразует высокоуровневые команды (`step`, `read_memory`) в GDB Machine Interface (MI3).
    *   **Уникальная особенность**: Использование `/proc/{pid}/maps`. Для поддержки бинарников без символов (`stripped`), контроллер напрямую читает карты памяти ядра Linux, чтобы найти базовый адрес загрузки (ImageBase). GDB часто не может этого сделать сам без символьной таблицы.

### 2.4. Database (The "Memory")
*   **Технологии**: SQLite (файловая).
*   **Изоляция сессий**: Для каждого отлаживаемого файла создается своя база данных (`crackme2_hash.db`). Это позволяет хранить:
    *   **Комментарии**: Пользовательские заметки к коду.
    *   **Патчи**: Историю изменений байт.
    *   **Revert Table**: Таблицу "Оригинальных значений", чтобы всегда можно было откатить патч, даже если процесс был перезапущен.

---

## 3. Потоки данных (Deep Dive)

### 3.1. Синхронные операции (Чтение Памяти)
(Используется для отрисовки Hex Dump или Disassembly)
1.  Frontend: `POST /memory/disassemble {start: 0x8048000}`.
2.  Backend: Генерирует UUID токен `req_123`.
3.  Backend -> GDB: `req_123-data-disassemble -s 0x8048000 ...`.
4.  Backend: Ждет `Future`, связанный с `req_123`.
5.  GDB: Выполняет работу...
6.  GDB -> Backend: `req_123^done,asm_insns=[...]`.
7.  Backend: Находит `req_123`, разблокирует HTTP запрос.
8.  Frontend: Получает JSON и обновляет Redux.

### 3.2. Асинхронные события (Шаг отладки)
(Используется для обновления UI после Step Into)
1.  Frontend: `POST /control/step`.
2.  Backend -> GDB: `-exec-step-instruction`.
    *   *Backend сразу возвращает 200 OK фронтенду, не дожидаясь остановки.*
3.  Приложение исполняет одну инструкцию.
4.  GDB -> Backend: `*stopped,reason="end-stepping-range",frame={addr="0x..."}`.
5.  Backend (Event Loop):
    *   Видит событие остановки.
    *   Автоматически запрашивает регистры (`-data-list-register-values`).
    *   Автоматически запрашивает метаданные.
6.  Backend -> Frontend (WebSocket):
    *   `{type: "status", payload: "PAUSED"}`
    *   `{type: "registers", payload: [...]}`
7.  Frontend: Обновляет UI, подсвечивает изменившиеся регистры красным.

---

## 4. Особенности реализации v0.1.2

### 4.1. Поддержка Stripped Binaries
Большинство CTF-задач и реальных вирусов не имеют отладочных символов.
*   Стандартный подход (`info files`) в GDB часто падает или выдает пустоту.
*   Наше решение: Парсинг `/proc/self/maps` (или `/proc/<pid>/maps`). Это дает гарантированно точный адрес загрузки (ImageBase), который затем используется для вычисления смещений (RVA).

### 4.2. Инициализация "Zero Address" (Bugfix)
При старте React-приложения, компоненты могут смонтироваться раньше, чем придут данные о регистрах.
Ранее это вызывало запрос дизассемблирования для адреса `0x0`, что приводило к ошибке GDB.
В v0.1.2 внедрена защита: хук `useMemory` игнорирует любые запросы к Null-Page, пока не получит валидный RIP от бэкенда.

### 4.3. Full-Screen Logging
Окно логов реализовано как "Overlay" с `z-index: 50`. Это позволяет пользователю мгновенно переключаться между кодом и логами, не теряя контекст и скролл-позицию в дизассемблере (так как компонент `DisassemblyPane` не размонтируется, а просто скрывается/перекрывается).
```