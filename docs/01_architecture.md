# Архитектура проекта Web-OllyDbg (v0.0.7)

## 1. Введение
Web-OllyDbg — это веб-интерфейс для отладчика GDB, разработанный для эмуляции User Experience (UX) классического отладчика OllyDbg (версии 1.10/2.01). Проект решает задачу предоставления привычного инструментария для реверс-инженеров в среде, где доступен только браузер, инкапсулируя сложность GDB под капотом.

## 2. Компоненты системы

Система построена на микросервисной архитектуре с использованием Docker для изоляции среды отладки.

### Высокоуровневая схема
```
[ Browser (User) ]
      |
      | HTTP (REST API) / WebSocket (Real-time Events)
      v
[ Nginx (Frontend Container) ] <--- Static Assets (React Vite Build)
      |
      | Proxy /api & /ws
      v
[ FastAPI (Backend Container) ]
      |
      | Subprocess (Asyncio Subprocess Exec)
      | STDIN / STDOUT Pipes
      v
[ GDB (Machine Interface v3) ]
      |
      | Ptrace (Linux Kernel API)
      v
[ Target Binary (ELF/PE) ]
```

### 2.1. Frontend (React)
*   **Роль**: Презентация данных, управление состоянием UI, обработка пользовательского ввода, эмуляция оконного интерфейса.
*   **Технологии**: React 18, Redux Toolkit, Styled Components, Vite.
*   **Философия**: "Толстый клиент". Фронтенд хранит полную копию необходимого состояния (регистры, видимую часть дизассемблера, историю навигации, логи) и вычисляет визуальное представление (форматирование чисел, подсветку синтаксиса, "красные" патчи).
*   **Ключевое изменение v0.0.7**: Внедрена концепция переключаемых "Видов" (Views). Основной режим — **CPU View** (Дизассемблер, Регистры, Дамп, Стек), второй режим — **System Log View** (полноэкранный лог). Это имитирует поведение OllyDbg (переключение окон через меню Window).

### 2.2. Backend (Python/FastAPI)
*   **Роль**: Управление жизненным циклом GDB, парсинг MI-ответов, работа с локальной базой данных (SQLite), проксирование команд.
*   **Технологии**: Python 3.14 (Slim), FastAPI, Uvicorn, Websockets, Pygdbmi.
*   **Архитектура**: Полностью асинхронная (`asyncio`).
    *   GDB запускается как подпроцесс.
    *   Чтение `stdout` GDB происходит в отдельной фоновой задаче (`Task`).
    *   **Token-Based Request Matching**: Для синхронизации ответов GDB с HTTP-запросами используется механизм уникальных токенов (UUID), что предотвращает состояние гонки (Race Conditions) при активном взаимодействии.

### 2.3. Database (SQLite)
*   **Роль**: Персистентное хранение метаданных отладочной сессии и глобальных настроек.
*   **Изоляция**:
    *   **Сессионные данные**: Для каждого отлаживаемого файла создается отдельная база данных вида `database/<target_name>_<md5_hash>.db`. Хранит патчи и комментарии.
    *   **Глобальные настройки**: Файл `database/app_settings.db` хранит настройки интерфейса (форматирование, кейсинг и т.д.).

### 2.4. GDB (GNU Debugger)
*   **Роль**: Непосредственное управление процессом (`ptrace`), чтение памяти, управление точками останова, пошаговая отладка.
*   **Режим работы**: Запускается с флагом `--interpreter=mi3`. Это заставляет GDB выдавать структурированные ответы (GDB/MI), которые парсятся библиотекой `pygdbmi`.

## 3. Потоки данных (Data Flow)

### 3.1. Синхронный поток (Command -> Response)
Используется для операций, требующих немедленного результата (например, чтение памяти перед патчингом).
1.  Frontend делает `POST /memory/write`.
2.  Backend генерирует UUID токен.
3.  Backend отправляет команду в GDB с префиксом токена: `[UUID]-data-read-memory-bytes ...`.
4.  Backend создает `asyncio.Future` и ждет.
5.  GDB выполняет команду и возвращает ответ с тем же токеном.
6.  Фоновый читатель GDB видит токен, находит `Future` и возвращает результат в HTTP ответ.

### 3.2. Асинхронный поток (Event -> Broadcast)
Используется для уведомлений о смене состояния.
1.  Пользователь нажимает Step Into (`-exec-step-instruction`).
2.  GDB выполняет шаг и останавливается.
3.  GDB пишет в stdout асинхронную запись `*stopped`.
4.  Backend парсит `*stopped`.
5.  Backend автоматически запрашивает регистры.
6.  Backend отправляет WebSocket событие `{type: "status", payload: "PAUSED"}` и `{type: "registers", ...}` всем клиентам.

## 4. Безопасность и ограничения
*   **Контейнеризация**: Процесс отладки происходит внутри Docker-контейнера. Это защищает хост-систему.
*   **Привилегии**: Контейнеру требуются `SYS_PTRACE` и `seccomp:unconfined` для возможности использовать системный вызов `ptrace`. Без этого отладка невозможна.
*   **Сетевая безопасность**: Аутентификация отсутствует. Проект предназначен для работы внутри защищенного периметра (VPN/Localhost).