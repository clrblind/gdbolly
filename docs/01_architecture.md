# Архитектура проекта Web-OllyDbg

## 1. Введение
Web-OllyDbg — это веб-интерфейс для отладчика GDB, который визуально и функционально имитирует классический отладчик OllyDbg (версии 1.10/2.01). Проект решает задачу предоставления привычного UX для реверс-инженеров в среде, где доступен только браузер, при этом используя мощь GDB под капотом.

## 2. Компоненты системы

Система построена на микросервисной архитектуре с использованием Docker для изоляции среды отладки.

### Высокоуровневая схема
```
[ Browser (User) ]
      |
      | HTTP / WebSocket
      v
[ Nginx (Frontend Container) ] <--- Static Assets (React)
      |
      | Proxy /api & /ws
      v
[ FastAPI (Backend Container) ]
      |
      | Subprocess (PIPEs)
      v
[ GDB (Machine Interface v3) ]
      |
      | Ptrace
      v
[ Target Binary (ELF/PE) ]
```

### 2.1. Frontend (React)
*   **Роль**: Презентация данных, управление состоянием UI, обработка пользовательского ввода.
*   **Технологии**: React 18, Redux Toolkit, Styled Components, Vite.
*   **Философия**: "Толстый клиент". Фронтенд хранит полную копию необходимого состояния (регистры, видимую часть дизассемблера, историю навигации) и вычисляет визуальное представление (форматирование чисел, подсветку синтаксиса). Бэкенд используется только как транспорт данных и исполнитель команд.

### 2.2. Backend (Python/FastAPI)
*   **Роль**: Управление жизненным циклом GDB, парсинг MI-ответов, работа с БД, проксирование команд.
*   **Технологии**: Python 3.11, FastAPI, Uvicorn, Websockets, Pygdbmi.
*   **Ключевая особенность**: Полная асинхронность (`asyncio`). GDB — это блокирующий процесс, поэтому взаимодействие с ним (чтение stdout) вынесено в отдельные фоновые задачи (Tasks), чтобы не блокировать HTTP-запросы и Heartbeat веб-сокетов.

### 2.3. Database (SQLite)
*   **Роль**: Персистентное хранение метаданных отладочной сессии.
*   **Данные**: Комментарии пользователя, список патчей (измененных байт), настройки.
*   **Изоляция**: Для каждого отлаживаемого файла создается отдельная база данных вида `filename_hash.db`. Это позволяет сохранять прогресс реверс-инжиниринга конкретного бинарника.

### 2.4. GDB (GNU Debugger)
*   **Роль**: Непосредственное управление процессом (ptrace), чтение памяти, управление точками останова.
*   **Режим работы**: Запускается с флагом `--interpreter=mi3`. Это заставляет GDB выдавать структурированные ответы (GDB/MI), которые легче парсить программно, чем человекочитаемый текст CLI.

## 3. Потоки данных (Data Flow)

### 3.1. Командный поток (Command Flow)
Пользователь нажимает "Step Into" -> Фронтенд шлет POST `/control/step_into` -> Бэкенд пишет `-exec-step` в stdin процесса GDB -> GDB выполняет шаг.

### 3.2. Событийный поток (Event Flow)
GDB завершает шаг и останавливается -> В stdout падает сообщение `*stopped` -> Бэкенд парсит его, понимает, что процесс встал -> Автоматически запрашивает регистры (`-data-list-register-values`) -> Формирует JSON -> Отправляет во все активные WebSocket соединения -> Фронтенд обновляет Redux Store.

**Важно:** Изначально бэкенд автоматически запрашивал и дизассемблерный листинг. В версии 0.0.2 это поведение изменено. Теперь фронтенд сам решает, когда обновлять листинг (например, если IP ушел за пределы видимости), чтобы избежать "дергания" интерфейса.

## 4. Безопасность и ограничения
*   **Контейнеризация**: Процесс отладки происходит внутри Docker-контейнера. Это защищает хост-систему, но требует привилегированного режима (`SYS_PTRACE`, `seccomp:unconfined`) для работы GDB.
*   **Сетевая безопасность**: В текущей версии отсутствуют механизмы аутентификации. Проект предназначен для локального использования или работы внутри закрытого периметра (VPN).
