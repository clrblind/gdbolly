# Внутреннее устройство Фронтенда (React/Redux)

## 1. Архитектура и Рефакторинг
Фронтенд реализован на **React 18** с использованием **Redux Toolkit**. Логика строго отделена от представления через Custom Hooks.

### 1.1. Структура Хуков (`src/hooks/`)
*   **`useAppLogic.js`**: "Корневой" хук. Агрегирует состояние и передает его в `App.jsx`.
*   **`useSessionManager.js`**: (Добавлен в v0.1) Отвечает за загрузку файлов, открытие сессий и, что важно, обработку **метаданных** (PID, Arch, ImageBase), получаемых от бэкенда.
*   **`useSocket.js`**: Слушает WebSocket события.
    - `status`: Смена состояния (RUNNING, PAUSED).
    - `registers`: Обновление регистров.
    - `metadata`: Асинхронное обновление PID/Arch.
*   **`useDebuggerControl.js`**: Управление исполнением (Step/Run) и горячие клавиши.
*   **`useMemory.js`**: Управление памятью, патчинг, контекстное меню, копирование.

## 2. Управление Состоянием (Redux: `store/debuggerSlice.js`)

### 2.1. Ключевые поля
*   **`metadata`**: Объект `{ pid, arch, imageBase }`. В v0.1.2 это поле стало top-level свойством (ранее было в settings), что исправило ошибки отображения в статус-баре.
*   **`viewStartAddress`**: Адрес визуального начала листинга.
*   **`modifiedAddresses`**: Список измененных адресов для подсветки.

### 2.2. Особенности
*   **Redux Middleware**: Логирование всех критических действий (`addSystemLog`) для отображения в окне System Log.
*   **Address Normalization**: Все адреса проходят через `utils/addressUtils.js` -> `normalizeAddress`, чтобы гарантировать формат `0x` + lowercase hex (избавляет от проблем типа `0x401000` != `4198400`).

## 3. Компоненты UI

### 3.1. Система Views
В `App.jsx` реализовано переключение между режимами:
1.  **CPU View**: Стандартная раскладка (Disassembly, Registers, Stack, Dump).
2.  **System Log View**: Полноэкранный оверлей логов.

### 3.2. Disassembly Pane
Реализует паттерн "Виртуальный скроллинг" (Pre-fetching). При прокрутке запрашивает новые порции инструкций у бэкенда.
*   **Важно**: В v0.1.2 добавлен "защитник" (guard clause) в `refreshDisassembly`, запрещающий запросы к адресу `0x0`. Это устранило ошибку "Cannot access memory at address 0x0" при инициализации.

## 4. Жизненный цикл Патчинга
1.  Пользователь вводит байт в модальном окне.
2.  `useMemory` отправляет POST `/memory/write`.
3.  Бэкенд проверяет валидность и пишет в память.
4.  Фронтенд получает 200 OK.
5.  Диспатчится action `markAddressModified`.
6.  Вызывается `refreshDisassembly` (сбрасывается кэш инструкций).
7.  Листинг перерисовывается, показывая новые инструкции и помечая их красным.