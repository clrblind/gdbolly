# Внутреннее устройство Бэкенда (Python/FastAPI)

## 1. Обзор
Бэкенд отвечает за трансляцию REST/WS запросов в команды GDB MI3. Код написан с использованием `asyncio` для обеспечения высокой конкурентности.

**Ключевые модули:**
*   `main.py.txt`: API контроллер.
*   `gdb_controller.py.txt`: Низкоуровневое управление процессом GDB.
*   `db_manager.py.txt`: Работа с сессионными БД (патчи, комментарии).
*   `settings_manager.py.txt`: Работа с глобальными настройками.

## 2. GDBController (`gdb_controller.py.txt`) — Ядро системы

Это самый сложный компонент, реализующий асинхронный мост к синхронному процессу GDB.

### 2.1. Проблема синхронизации
GDB MI (Machine Interface) асинхронен по своей природе. Вы отправляете команду, а ответ может прийти через неопределенное время, перемежаясь с другими уведомлениями (например, логами потоков).
В ранних версиях это приводило к состоянию гонки (Race Condition), когда ответ на команду `Read Memory` терялся или путался с другим ответом.

### 2.2. Решение: Система Токенов (UUID)
В версии 0.0.6 внедрена система токенов.

1.  **Отправка**:
    При вызове метода `read_memory(addr, len)`:
    *   Генерируется уникальный токен: `token = uuid.uuid4().hex`.
    *   Создается `asyncio.Future`, который сохраняется в словарь `self.callbacks[token]`.
    *   В GDB отправляется команда с префиксом: `token-command args` (например, `abc1234-data-read-memory-bytes ...`).

2.  **Получение (`_read_stdout`)**:
    Бесконечный цикл читает stdout. Библиотека `pygdbmi` парсит вывод.
    *   Если в ответе есть поле `token`: Проверяется наличие этого токена в `self.callbacks`.
    *   Если токен найден: `future.set_result(payload)` (или `set_exception` при ошибке).
    *   Если токена нет (или это уведомление `*stopped`): Сообщение отправляется в общую очередь WebSocket `msg_queue`.

### 2.3. Таймауты
Все операции с ожиданием ответа обернуты в `asyncio.wait_for(..., timeout=4.0)`. Это предотвращает зависание бэкенда, если GDB "умер" или завис при чтении памяти.

## 3. Логика Патчинга ("Safe Patching")
Реализована в эндпоинте `/memory/write` (`main.py.txt`).
Обеспечивает целостность данных для функции отката (Revert).

**Алгоритм:**
1.  **Чтение оригинала**: Сначала вызывается `gdb.read_memory` для адреса записи.
    *   *Критично*: Если чтение не удалось (таймаут или ошибка доступа), операция прерывается. Патч **не** применяется. Это гарантирует, что мы не запишем мусор в базу данных как "оригинальные байты".
2.  **Запись в память**: Вызывается `gdb.write_memory` с новыми байтами.
3.  **Сохранение**: В `db_manager` сохраняется тройка: `(address, original_bytes, new_bytes)`.

## 4. Менеджеры Баз Данных

### 4.1. DBManager (Сессии)
*   Файл: `database/<target>_<hash>.db`.
*   Использует `asyncio.to_thread` для всех SQL операций, чтобы не блокировать Event Loop (драйвер `sqlite3` блокирующий).
*   Таблица `patches` хранит историю изменений. При повторном запуске приложения эти данные отправляются на фронтенд, который подсвечивает измененные участки, но **не** применяет их автоматически к памяти (пользователь должен видеть чистое состояние процесса, но знать о своих прошлых правках). *Примечание: в будущих версиях возможно авто-применение патчей.*

### 4.2. SettingsManager (Настройки)
*   Файл: `database/app_settings.db`.
*   Хранит настройки как Key-Value (TEXT, TEXT).
*   Используется для сохранения предпочтений интерфейса (темы, форматы чисел) между перезапусками контейнера.

## 5. Логирование
Логи больше не пишутся в консоль сервера с префиксом `[LOG]`. Вместо этого используется функция `broadcast_log`, которая отправляет сырое сообщение через WebSocket с типом `system_log`.
Форматирование времени и отображение перенесено на сторону клиента (Frontend), чтобы обеспечить единый таймлайн событий.