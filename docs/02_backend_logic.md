# Внутреннее устройство Бэкенда (Python/FastAPI)

## 1. Обзор
Бэкенд отвечает за трансляцию REST/WS запросов в команды GDB MI3. Проект построен на базе **Python 3.13** и **FastAPI**, используя `asyncio` для обеспечения высокой конкурентности.

**Ключевые модули (`backend/app`):**
*   `routers/session.py`: Управление сессией (загрузка бинарников, компиляция, инициализация БД).
*   `routers/control.py`: Управление исполнением (Step, Run, Pause).
*   `routers/memory.py`: Чтение/Запись памяти, дизассемблирование.
*   `routers/settings.py`: Управление глобальными настройками.
*   `routers/websocket.py`: Broadcaster событий.

**Ядро GDB (`backend/gdb`):**
*   `controller.py`: Singleton-класс `GDBController`, реализующий низкоуровневое взаимодействие с процессом.

## 2. GDBController (`gdb/controller.py`) — Ядро системы

Это самый сложный компонент, реализующий асинхронный мост к синхронному процессу GDB.

### 2.1. Проблема синхронизации
GDB MI (Machine Interface) асинхронен. Вы отправляете команду, а ответ может прийти через неопределенное время.
*Решение*: **Token-Based Synchronization**.

### 2.2. Система Токенов (UUID)
1.  **Отправка**: Генерируется уникальный токен. Команда отправляется как `[UUID]-команда аргументы`.
2.  **Получение**: Парсер `_read_stdout` ищет токен в ответе. При совпадении результат возвращается в соответствующий `asyncio.Future`.
3.  **Таймауты**: Все операции обернуты в `wait_for` (4.0 сек) для предотвращения зависаний.

### 2.3. Работа с Stripped Binaries (v0.1.2)
Одной из ключевых особенностей v0.1.2 является поддержка бинарных файлов без символьной информации.
*   **Проблема**: GDB не может определить точку входа или Image Base через символы (`_start` отсутствует).
*   **Решение**: Контроллер читает файл `/proc/{pid}/maps` (через файловую систему Linux внутри контейнера), чтобы найти адрес загрузки исполняемого сегмента. Это гарантирует корректное определение `ImageBase` даже для "голых" ELF-файлов.

## 3. Логика Патчинга ("Safe Patching")
Реализована в `routers/memory.py`.
**Алгоритм:**
1.  **Чтение оригинала**: Сначала читаются текущие байты по адресу.
2.  **Валидация**: Если чтение не удалось, операция прерывается.
3.  **Запись**: Выполняется `gdb.write_memory`.
4.  **Сохранение**: В БД сохраняется тройка `(addr, old_bytes, new_bytes)` для возможности отката (Revert).

## 4. Базы Данных (`backend/db_manager.py`)
Используется **SQLite** с асинхронным доступом (`asyncio.to_thread`).
*   **Сессионные БД**: `database/<binary_name>_<hash>.db`. Хранят состояние конкретного бинарника.
*   **Глобальные настройки**: `database/app_settings.db`.

## 5. Логирование
Задействован механизм **Broadcast**. Логи не пишутся в stdout контейнера (кроме критических ошибок старта), а отправляются через WebSocket напрямую в компонент `SystemLogWindow` на фронтенде. Это позволяет пользователю видеть полную трассировку команд GDB (TX/RX).