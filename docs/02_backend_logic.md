# Документация Бэкенда (Python/FastAPI)

## 1. Структура проекта
Бэкенд расположен в директории `backend/` и состоит из следующих ключевых файлов:
*   `main.py.txt`: Точка входа FastAPI, определение маршрутов (Routes) и WebSocket ендпоинта.
*   `gdb_controller.py.txt`: Класс-обертка над подпроцессом GDB. Сердце логики отладки.
*   `db_manager.py.txt`: Слой абстракции для работы с SQLite.

## 2. GDBController (`gdb_controller.py.txt`)

Этот класс управляет единственным экземпляром процесса GDB. Поскольку GDB не рассчитан на многопоточный доступ, контроллер реализует очередь сообщений и асинхронное чтение.

### 2.1. Управление процессом
*   **Запуск (`start`)**:
    1.  Принудительно завершает предыдущую сессию (kill process, cancel tasks).
    2.  Запускает `gdb --interpreter=mi3 --args <binary>`.
    3.  Создает асинхронную задачу (`self.io_task`) для непрерывного чтения `stdout` процесса.
    4.  Важно: Используется `asyncio.create_subprocess_exec` с пайпами.

*   **Остановка (`stop`)**:
    Критически важный метод для предотвращения утечек ресурсов и Race Condition.
    1.  Отменяет `io_task`.
    2.  Ждет завершения отмены (suppress CancelledError).
    3.  Посылает `terminate` процессу.
    4.  Это предотвращает ситуацию, когда старая корутина пытается читать вывод нового процесса.

### 2.2. Чтение вывода (`_read_stdout`)
Бесконечный цикл, читающий строки из `process.stdout`.
Использует библиотеку `pygdbmi` для парсинга MI-строк в Python-словари.

*   **Обработка токенов**: GDB позволяет помечать команды токенами. Если ответ содержит токен, контроллер ищет соответствующий `Future` в словаре `self.callbacks` и резолвит его. Это позволяет реализовать синхронный (с точки зрения вызова) метод `read_memory`, который ждет ответа от GDB.
*   **Обработка событий**: Сообщения типа `notify` (например, `stopped`) обрабатываются отдельно — они инициируют рассылку обновлений через WebSocket.

### 2.3. Работа с памятью
*   **`write_memory`**: Использует команду GDB `set {char[N]}ADDR = {bytes}`. Перед записью выполняется валидация данных (проверка на `None` и `NaN`), чтобы не уронить процесс форматированием строки.
*   **`read_memory`**: Использует команду `-data-read-memory-bytes`. Реализовано через механизм `Future` и токенов, так как нам нужно вернуть данные непосредственно в HTTP-ответ, а не просто отправить в сокет.

## 3. DBManager (`db_manager.py.txt`)

Отвечает за персистентность данных.

### 3.1. Схема базы данных
Для каждого бинарника создается файл: `database/<target_name>_<md5_hash>.db`.

Таблицы:
1.  **`comments`**:
    *   `address` (TEXT PRIMARY KEY): Адрес в hex формате (0x...).
    *   `comment` (TEXT): Текст комментария.

2.  **`patches`**:
    *   `address` (TEXT PRIMARY KEY): Адрес начала патча.
    *   `orig_bytes` (TEXT): Исходные байты (hex string, напр "9090"), необходимы для функции Revert.
    *   `new_bytes` (TEXT): Новые байты.
    *   `enabled` (INTEGER): Флаг активности (задел на будущее).

### 3.2. Логика работы
Все операции ввода-вывода (IO) с базой данных обернуты в `asyncio.to_thread`. SQLite драйвер в Python блокирующий, и выполнение SQL-запросов в основном Event Loop'е может зафризить обработку WebSocket сообщений. Вынос в тредпул решает эту проблему.

## 4. Основные Endpoints (`main.py.txt`)

*   `POST /session/load`: Инициализирует БД, запускает GDB, возвращает сохраненные комментарии и патчи.
*   `POST /memory/write`: Патчинг. Читает оригинал -> Пишет новое -> Сохраняет в БД патч.
*   `POST /memory/revert`: Откат. Читает оригинал из БД -> Пишет в память -> Удаляет запись из БД.
*   `POST /memory/disassemble`: Получает листинг. Принимает `start` и `count`. Вычисляет конечный адрес эвристически (x8 инструкций).
*   `WS /ws`: Канал для push-уведомлений (смена статуса, регистры, логи).
